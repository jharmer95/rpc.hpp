<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rpc.hpp: include/rpc.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rpc.hpp
   &#160;<span id="projectnumber">0.2.1</span>
   </div>
   <div id="projectbrief">Simple RPC Header-Only Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">rpc.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header-only library for serialized RPC usage.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;any&gt;</code><br />
<code>#include &lt;future&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for rpc.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="rpc_8hpp__incl.png" border="0" usemap="#include_2rpc_8hpp" alt=""/></div>
<map name="include_2rpc_8hpp" id="include_2rpc_8hpp">
<area shape="rect" title="Header&#45;only library for serialized RPC usage." alt="" coords="173,5,283,32"/>
<area shape="rect" title=" " alt="" coords="5,80,48,107"/>
<area shape="rect" title=" " alt="" coords="73,80,127,107"/>
<area shape="rect" title=" " alt="" coords="152,80,219,107"/>
<area shape="rect" title=" " alt="" coords="243,80,298,107"/>
<area shape="rect" title=" " alt="" coords="323,80,373,107"/>
<area shape="rect" title=" " alt="" coords="397,80,451,107"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="rpc_8hpp__dep__incl.png" border="0" usemap="#include_2rpc_8hppdep" alt=""/></div>
<map name="include_2rpc_8hppdep" id="include_2rpc_8hppdep">
<area shape="rect" title="Header&#45;only library for serialized RPC usage." alt="" coords="104,5,215,32"/>
<area shape="rect" href="rpc__njson_8hpp.html" title="Implementation of adapting nlohmann/json (https://github.com/nlohmann/json)" alt="" coords="5,80,148,121"/>
<area shape="rect" href="rpc__rapidjson_8hpp.html" title="Implementation of adapting rapidjson (https://github.com/Tencent/rapidjson)" alt="" coords="172,80,315,121"/>
</map>
</div>
</div>
<p><a href="rpc_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpc_1_1details_1_1has__begin.html">rpc::details::has_begin&lt; C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE struct for checking a type for a 'begin' member function.  <a href="structrpc_1_1details_1_1has__begin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpc_1_1details_1_1has__end.html">rpc::details::has_end&lt; C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE struct for checking a type for a 'end' member function.  <a href="structrpc_1_1details_1_1has__end.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpc_1_1details_1_1has__size.html">rpc::details::has_size&lt; C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE struct for checking a type for a 'size' member function.  <a href="structrpc_1_1details_1_1has__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpc_1_1details_1_1is__container.html">rpc::details::is_container&lt; C &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE struct to determine if a type is a container.  <a href="structrpc_1_1details_1_1is__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpc_1_1details_1_1ptr__decay.html">rpc::details::ptr_decay&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to decay arrays to pointers.  <a href="structrpc_1_1details_1_1ptr__decay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrpc_1_1details_1_1bool__pack.html">rpc::details::bool_pack&lt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy struct for all_true.  <a href="structrpc_1_1details_1_1bool__pack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrpc_1_1details_1_1dyn__array.html">rpc::details::dyn_array&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically sized generic array class. Has a fixed max capacity and a dynamic size.  <a href="classrpc_1_1details_1_1dyn__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrpc_1_1packed__func__base.html">rpc::packed_func_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic base class for <a class="el" href="classrpc_1_1packed__func.html">packed_func</a>.  <a href="classrpc_1_1packed__func__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrpc_1_1packed__func.html">rpc::packed_func&lt; R, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class reprensenting a function call including its name, result, and parameters.  <a href="classrpc_1_1packed__func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrpc_1_1packed__func_3_01void_00_01_args_8_8_8_01_4.html">rpc::packed_func&lt; void, Args... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class reprensenting a function call (with void result) including its name and parameters.  <a href="classrpc_1_1packed__func_3_01void_00_01_args_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrpc_1_1serial__adapter.html">rpc::serial_adapter&lt; Serial &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class that provides an interface for going to and from a <a class="el" href="classrpc_1_1packed__func.html">packed_func</a> and a serial object.  <a href="classrpc_1_1serial__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrpc_1_1client_1_1client__base.html">rpc::client::client_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic base class for sending and receiving data to/from the server.  <a href="classrpc_1_1client_1_1client__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacerpc_1_1details"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1details.html">rpc::details</a></td></tr>
<tr class="memdesc:namespacerpc_1_1details"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for functions/variables that should be used only from within the library. Using anything in this namespace in your project is discouraged. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerpc_1_1server"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1server.html">rpc::server</a></td></tr>
<tr class="memdesc:namespacerpc_1_1server"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for server-specific functions and variables Client-side code should not need to use anything in this namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacerpc_1_1client"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1client.html">rpc::client</a></td></tr>
<tr class="memdesc:namespacerpc_1_1client"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace containing client-specific functions and classes Server-side code should not need anything from this namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1caea5a41c2e1e503fd088efcdef0cd6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1caea5a41c2e1e503fd088efcdef0cd6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1details.html#a1caea5a41c2e1e503fd088efcdef0cd6">rpc::details::ptr_decay_t</a> = typename ptr_decay&lt; T &gt;::type</td></tr>
<tr class="memdesc:a1caea5a41c2e1e503fd088efcdef0cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="structrpc_1_1details_1_1ptr__decay.html" title="Structure to decay arrays to pointers.">ptr_decay</a> struct.  <a href="namespacerpc_1_1details.html#a1caea5a41c2e1e503fd088efcdef0cd6">More...</a><br /></td></tr>
<tr class="separator:a1caea5a41c2e1e503fd088efcdef0cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3136deccde141f3c5c14e434a81d578"><td class="memTemplParams" colspan="2">template&lt;bool... bs&gt; </td></tr>
<tr class="memitem:ab3136deccde141f3c5c14e434a81d578"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1details.html#ab3136deccde141f3c5c14e434a81d578">rpc::details::all_true</a> = std::is_same&lt; bool_pack&lt; bs..., true &gt;, bool_pack&lt; true, bs... &gt; &gt;</td></tr>
<tr class="memdesc:ab3136deccde141f3c5c14e434a81d578"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE struct for checking if all packed bool parameters are true.  <a href="namespacerpc_1_1details.html#ab3136deccde141f3c5c14e434a81d578">More...</a><br /></td></tr>
<tr class="separator:ab3136deccde141f3c5c14e434a81d578"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae8d1b65246a88c23eb066636f9ca89e1"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Ts, size_t... Is&gt; </td></tr>
<tr class="memitem:ae8d1b65246a88c23eb066636f9ca89e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1details.html#ae8d1b65246a88c23eb066636f9ca89e1">rpc::details::for_each_tuple</a> (const std::tuple&lt; Ts... &gt; &amp;tuple, const F &amp;func, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:ae8d1b65246a88c23eb066636f9ca89e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation of meta-programming function.  <a href="namespacerpc_1_1details.html#ae8d1b65246a88c23eb066636f9ca89e1">More...</a><br /></td></tr>
<tr class="separator:ae8d1b65246a88c23eb066636f9ca89e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ae7b31c81651d6979286f5f30cf46b"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:a58ae7b31c81651d6979286f5f30cf46b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1details.html#a58ae7b31c81651d6979286f5f30cf46b">rpc::details::for_each_tuple</a> (const std::tuple&lt; Ts... &gt; &amp;tuple, const F &amp;func)</td></tr>
<tr class="memdesc:a58ae7b31c81651d6979286f5f30cf46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-programming function to apply a function over each member of a tuple.  <a href="namespacerpc_1_1details.html#a58ae7b31c81651d6979286f5f30cf46b">More...</a><br /></td></tr>
<tr class="separator:a58ae7b31c81651d6979286f5f30cf46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9aac69687b613761b8c9f30598ae21"><td class="memTemplParams" colspan="2">template&lt;typename Serial , typename Value &gt; </td></tr>
<tr class="memitem:aca9aac69687b613761b8c9f30598ae21"><td class="memTemplItemLeft" align="right" valign="top">Serial&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rpc_8hpp.html#aca9aac69687b613761b8c9f30598ae21">rpc::serialize</a> (const Value &amp;val)</td></tr>
<tr class="memdesc:aca9aac69687b613761b8c9f30598ae21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes a generic object to a serial object.  <a href="rpc_8hpp.html#aca9aac69687b613761b8c9f30598ae21">More...</a><br /></td></tr>
<tr class="separator:aca9aac69687b613761b8c9f30598ae21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90caf447061a735645909db98d294b8c"><td class="memTemplParams" colspan="2">template&lt;typename Serial , typename Value &gt; </td></tr>
<tr class="memitem:a90caf447061a735645909db98d294b8c"><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rpc_8hpp.html#a90caf447061a735645909db98d294b8c">rpc::deserialize</a> (const Serial &amp;serial_obj)</td></tr>
<tr class="memdesc:a90caf447061a735645909db98d294b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-serializes a serial object to a generic object.  <a href="rpc_8hpp.html#a90caf447061a735645909db98d294b8c">More...</a><br /></td></tr>
<tr class="separator:a90caf447061a735645909db98d294b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bee9d6b42073cac75972e1357ab417"><td class="memTemplParams" colspan="2">template&lt;typename Serial , typename Value &gt; </td></tr>
<tr class="memitem:a16bee9d6b42073cac75972e1357ab417"><td class="memTemplItemLeft" align="right" valign="top">std::remove_cv_t&lt; std::remove_reference_t&lt; Value &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1details.html#a16bee9d6b42073cac75972e1357ab417">rpc::details::arg_from_serial</a> (const Serial &amp;obj)</td></tr>
<tr class="memdesc:a16bee9d6b42073cac75972e1357ab417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a single argument value from a serial object.  <a href="namespacerpc_1_1details.html#a16bee9d6b42073cac75972e1357ab417">More...</a><br /></td></tr>
<tr class="separator:a16bee9d6b42073cac75972e1357ab417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429be958a0bfccbac4007a870945329d"><td class="memTemplParams" colspan="2">template&lt;typename Serial , typename Value &gt; </td></tr>
<tr class="memitem:a429be958a0bfccbac4007a870945329d"><td class="memTemplItemLeft" align="right" valign="top">std::remove_cv_t&lt; std::remove_reference_t&lt; Value &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1details.html#a429be958a0bfccbac4007a870945329d">rpc::details::args_from_serial</a> (const Serial &amp;obj, unsigned &amp;arg_index)</td></tr>
<tr class="memdesc:a429be958a0bfccbac4007a870945329d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the argument values from a serial object.  <a href="namespacerpc_1_1details.html#a429be958a0bfccbac4007a870945329d">More...</a><br /></td></tr>
<tr class="separator:a429be958a0bfccbac4007a870945329d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e97882d2cf6f10593661e1094242b2a"><td class="memTemplParams" colspan="2">template&lt;typename Value , typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a1e97882d2cf6f10593661e1094242b2a"><td class="memTemplItemLeft" align="right" valign="top">std::remove_cv_t&lt; std::remove_reference_t&lt; Value &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1details.html#a1e97882d2cf6f10593661e1094242b2a">rpc::details::args_from_packed</a> (const packed_func&lt; R, Args... &gt; &amp;pack, unsigned &amp;arg_index)</td></tr>
<tr class="memdesc:a1e97882d2cf6f10593661e1094242b2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks the argument values from a <a class="el" href="classrpc_1_1packed__func.html">packed_func</a>.  <a href="namespacerpc_1_1details.html#a1e97882d2cf6f10593661e1094242b2a">More...</a><br /></td></tr>
<tr class="separator:a1e97882d2cf6f10593661e1094242b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccb390ea6797f5451f75dd6dc5810d8"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:acccb390ea6797f5451f75dd6dc5810d8"><td class="memTemplItemLeft" align="right" valign="top">packed_func&lt; R, Args... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1server.html#acccb390ea6797f5451f75dd6dc5810d8">rpc::server::convert_func</a> ([[maybe_unused]] std::function&lt; R(Args...)&gt; unused, const packed_func_base &amp;pack)</td></tr>
<tr class="memdesc:acccb390ea6797f5451f75dd6dc5810d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classrpc_1_1packed__func__base.html">packed_func_base</a> to a specific templated <a class="el" href="classrpc_1_1packed__func.html">packed_func</a>.  <a href="namespacerpc_1_1server.html#acccb390ea6797f5451f75dd6dc5810d8">More...</a><br /></td></tr>
<tr class="separator:acccb390ea6797f5451f75dd6dc5810d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad989490205e8e52f38431baf497b8d18"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:ad989490205e8e52f38431baf497b8d18"><td class="memTemplItemLeft" align="right" valign="top">packed_func&lt; R, Args... &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1server.html#ad989490205e8e52f38431baf497b8d18">rpc::server::convert_func</a> ([[maybe_unused]] R(*unused)(Args...), const packed_func_base &amp;pack)</td></tr>
<tr class="memdesc:ad989490205e8e52f38431baf497b8d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classrpc_1_1packed__func__base.html">packed_func_base</a> to a specific templated <a class="el" href="classrpc_1_1packed__func.html">packed_func</a>.  <a href="namespacerpc_1_1server.html#ad989490205e8e52f38431baf497b8d18">More...</a><br /></td></tr>
<tr class="separator:ad989490205e8e52f38431baf497b8d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467506ef5ec586fd10b16ddb5b1f683b"><td class="memTemplParams" colspan="2">template&lt;typename Serial , typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a467506ef5ec586fd10b16ddb5b1f683b"><td class="memTemplItemLeft" align="right" valign="top">packed_func&lt; R, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1server.html#a467506ef5ec586fd10b16ddb5b1f683b">rpc::server::create_func</a> ([[maybe_unused]] R(*unused)(Args...), const Serial &amp;obj)</td></tr>
<tr class="memdesc:a467506ef5ec586fd10b16ddb5b1f683b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classrpc_1_1packed__func.html">packed_func</a> object from a serial object.  <a href="namespacerpc_1_1server.html#a467506ef5ec586fd10b16ddb5b1f683b">More...</a><br /></td></tr>
<tr class="separator:a467506ef5ec586fd10b16ddb5b1f683b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9886cf779e8164ca16a94509c0b9481e"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a9886cf779e8164ca16a94509c0b9481e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1server.html#a9886cf779e8164ca16a94509c0b9481e">rpc::server::run_callback</a> (std::function&lt; R(Args...)&gt; func, packed_func&lt; R, Args... &gt; &amp;pack)</td></tr>
<tr class="memdesc:a9886cf779e8164ca16a94509c0b9481e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the callback function and populates the <a class="el" href="classrpc_1_1packed__func.html">packed_func</a> with the result and/or updated arguments.  <a href="namespacerpc_1_1server.html#a9886cf779e8164ca16a94509c0b9481e">More...</a><br /></td></tr>
<tr class="separator:a9886cf779e8164ca16a94509c0b9481e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dfa6764d97f2af25cb30018e880d29"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:aa8dfa6764d97f2af25cb30018e880d29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1server.html#aa8dfa6764d97f2af25cb30018e880d29">rpc::server::run_callback</a> (R(*func)(Args...), packed_func&lt; R, Args... &gt; &amp;pack)</td></tr>
<tr class="memdesc:aa8dfa6764d97f2af25cb30018e880d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the callback function and populates the <a class="el" href="classrpc_1_1packed__func.html">packed_func</a> with the result and/or updated arguments.  <a href="namespacerpc_1_1server.html#aa8dfa6764d97f2af25cb30018e880d29">More...</a><br /></td></tr>
<tr class="separator:aa8dfa6764d97f2af25cb30018e880d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5b4053728de37db48eeff03adb726a"><td class="memTemplParams" colspan="2">template&lt;typename Serial &gt; </td></tr>
<tr class="memitem:a8a5b4053728de37db48eeff03adb726a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1server.html#a8a5b4053728de37db48eeff03adb726a">rpc::server::dispatch</a> (Serial &amp;serial_obj)</td></tr>
<tr class="memdesc:a8a5b4053728de37db48eeff03adb726a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the function call based on the received serial object.  <a href="namespacerpc_1_1server.html#a8a5b4053728de37db48eeff03adb726a">More...</a><br /></td></tr>
<tr class="separator:a8a5b4053728de37db48eeff03adb726a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857940201b27225eb042bebe89d48d6c"><td class="memTemplParams" colspan="2">template&lt;typename Serial , typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a857940201b27225eb042bebe89d48d6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1server.html#a857940201b27225eb042bebe89d48d6c">rpc::server::dispatch_func</a> (R(*func)(Args...), Serial &amp;serial_obj)</td></tr>
<tr class="memdesc:a857940201b27225eb042bebe89d48d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches an individual function (to be called from <a class="el" href="namespacerpc_1_1server.html#a8a5b4053728de37db48eeff03adb726a">dispatch</a>)  <a href="namespacerpc_1_1server.html#a857940201b27225eb042bebe89d48d6c">More...</a><br /></td></tr>
<tr class="separator:a857940201b27225eb042bebe89d48d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47093157d082e708aafd4420fa5fbeca"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args&gt; </td></tr>
<tr class="memitem:a47093157d082e708aafd4420fa5fbeca"><td class="memTemplItemLeft" align="right" valign="top">packed_func&lt; R, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1client.html#a47093157d082e708aafd4420fa5fbeca">rpc::client::pack_call</a> (const std::string &amp;func_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a47093157d082e708aafd4420fa5fbeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packages a function call into a <a class="el" href="classrpc_1_1packed__func.html">packed_func</a>.  <a href="namespacerpc_1_1client.html#a47093157d082e708aafd4420fa5fbeca">More...</a><br /></td></tr>
<tr class="separator:a47093157d082e708aafd4420fa5fbeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c4e44da971e7265bc4ffb348ceb39b"><td class="memTemplParams" colspan="2">template&lt;typename Serial , typename R  = void, typename... Args&gt; </td></tr>
<tr class="memitem:a97c4e44da971e7265bc4ffb348ceb39b"><td class="memTemplItemLeft" align="right" valign="top">Serial&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1client.html#a97c4e44da971e7265bc4ffb348ceb39b">rpc::client::serialize_call</a> (const std::string &amp;func_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a97c4e44da971e7265bc4ffb348ceb39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a function call to a serial object.  <a href="namespacerpc_1_1client.html#a97c4e44da971e7265bc4ffb348ceb39b">More...</a><br /></td></tr>
<tr class="separator:a97c4e44da971e7265bc4ffb348ceb39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d575d06886d0a96523f6db931a377f"><td class="memTemplParams" colspan="2">template&lt;typename Serial , typename R  = void, typename... Args&gt; </td></tr>
<tr class="memitem:a57d575d06886d0a96523f6db931a377f"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; Serial &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1client.html#a57d575d06886d0a96523f6db931a377f">rpc::client::async_serialize_call</a> (const std::string &amp;func_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a57d575d06886d0a96523f6db931a377f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a function call to a serial object (asynchronously)  <a href="namespacerpc_1_1client.html#a57d575d06886d0a96523f6db931a377f">More...</a><br /></td></tr>
<tr class="separator:a57d575d06886d0a96523f6db931a377f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f2c96312c358f9c7e0752f67c23c13"><td class="memTemplParams" colspan="2">template&lt;typename Serial &gt; </td></tr>
<tr class="memitem:a58f2c96312c358f9c7e0752f67c23c13"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1client.html#a58f2c96312c358f9c7e0752f67c23c13">rpc::client::send_to_server</a> (const Serial &amp;serial_obj, client_base &amp;client)</td></tr>
<tr class="memdesc:a58f2c96312c358f9c7e0752f67c23c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a serialized function call to the server.  <a href="namespacerpc_1_1client.html#a58f2c96312c358f9c7e0752f67c23c13">More...</a><br /></td></tr>
<tr class="separator:a58f2c96312c358f9c7e0752f67c23c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd8addad53cdb47daa393525d3fb84e"><td class="memTemplParams" colspan="2">template&lt;typename Serial &gt; </td></tr>
<tr class="memitem:a1bd8addad53cdb47daa393525d3fb84e"><td class="memTemplItemLeft" align="right" valign="top">Serial&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1client.html#a1bd8addad53cdb47daa393525d3fb84e">rpc::client::get_server_response</a> (client_base &amp;client)</td></tr>
<tr class="memdesc:a1bd8addad53cdb47daa393525d3fb84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the server's response to the client call.  <a href="namespacerpc_1_1client.html#a1bd8addad53cdb47daa393525d3fb84e">More...</a><br /></td></tr>
<tr class="separator:a1bd8addad53cdb47daa393525d3fb84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addceb30f1a6d332b79fa969ee1d047fd"><td class="memTemplParams" colspan="2">template&lt;typename Serial , typename R  = void, typename... Args&gt; </td></tr>
<tr class="memitem:addceb30f1a6d332b79fa969ee1d047fd"><td class="memTemplItemLeft" align="right" valign="top">packed_func&lt; R, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1client.html#addceb30f1a6d332b79fa969ee1d047fd">rpc::client::call</a> (client_base &amp;client, const std::string &amp;func_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:addceb30f1a6d332b79fa969ee1d047fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packages and sends/receives a serialized function call in one easy function.  <a href="namespacerpc_1_1client.html#addceb30f1a6d332b79fa969ee1d047fd">More...</a><br /></td></tr>
<tr class="separator:addceb30f1a6d332b79fa969ee1d047fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7379a0c8f9578167777f74ee4e0a969a"><td class="memTemplParams" colspan="2">template&lt;typename Serial , typename R  = void, typename... Args&gt; </td></tr>
<tr class="memitem:a7379a0c8f9578167777f74ee4e0a969a"><td class="memTemplItemLeft" align="right" valign="top">std::future&lt; packed_func&lt; R, Args... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1client.html#a7379a0c8f9578167777f74ee4e0a969a">rpc::client::async_call</a> (client_base &amp;client, const std::string &amp;func_name, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7379a0c8f9578167777f74ee4e0a969a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packages and sends/receives a serialized function call in one easy function (asynchronously)  <a href="namespacerpc_1_1client.html#a7379a0c8f9578167777f74ee4e0a969a">More...</a><br /></td></tr>
<tr class="separator:a7379a0c8f9578167777f74ee4e0a969a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a00979fb7b4af46c0f6325866c8ce4cf4"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a00979fb7b4af46c0f6325866c8ce4cf4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1details.html#a00979fb7b4af46c0f6325866c8ce4cf4">rpc::details::is_container_v</a> = is_container&lt;C&gt;::value</td></tr>
<tr class="memdesc:a00979fb7b4af46c0f6325866c8ce4cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable for <a class="el" href="structrpc_1_1details_1_1is__container.html">is_container</a>.  <a href="namespacerpc_1_1details.html#a00979fb7b4af46c0f6325866c8ce4cf4">More...</a><br /></td></tr>
<tr class="separator:a00979fb7b4af46c0f6325866c8ce4cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9815966e0094dec96d37bc25c9f28d5"><td class="memTemplParams" colspan="2">template&lt;bool... bs&gt; </td></tr>
<tr class="memitem:ac9815966e0094dec96d37bc25c9f28d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacerpc_1_1details.html#ac9815966e0094dec96d37bc25c9f28d5">rpc::details::all_true_v</a> = all_true&lt;bs...&gt;::value</td></tr>
<tr class="memdesc:ac9815966e0094dec96d37bc25c9f28d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for all_true.  <a href="namespacerpc_1_1details.html#ac9815966e0094dec96d37bc25c9f28d5">More...</a><br /></td></tr>
<tr class="separator:ac9815966e0094dec96d37bc25c9f28d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header-only library for serialized RPC usage. </p>
<dl class="section author"><dt>Author</dt><dd>Jackson Harmer (<a href="#" onclick="location.href='mai'+'lto:'+'jha'+'rm'+'er9'+'5@'+'gma'+'il'+'.co'+'m'; return false;">jharm<span style="display: none;">.nosp@m.</span>er95<span style="display: none;">.nosp@m.</span>@gmai<span style="display: none;">.nosp@m.</span>l.co<span style="display: none;">.nosp@m.</span>m</a>) </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.2.2 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>11-12-2020</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>BSD 3-Clause License</dd></dl>
<p>Copyright (c) 2020, Jackson Harmer All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a90caf447061a735645909db98d294b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90caf447061a735645909db98d294b8c">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Serial , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value rpc::deserialize </td>
          <td>(</td>
          <td class="paramtype">const Serial &amp;&#160;</td>
          <td class="paramname"><em>serial_obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-serializes a serial object to a generic object. </p>
<dl class="section note"><dt>Note</dt><dd>This template must be instantiated for every custom struct/class that needs to be passed as a result or parameter via RPC </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Serial</td><td>The type of serial object to use </td></tr>
    <tr><td class="paramname">Value</td><td>The type of generic object to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial_obj</td><td>The serial object to be de-serialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value The de-serialized value </dd></dl>

</div>
</div>
<a id="aca9aac69687b613761b8c9f30598ae21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9aac69687b613761b8c9f30598ae21">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Serial , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Serial rpc::serialize </td>
          <td>(</td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes a generic object to a serial object. </p>
<dl class="section note"><dt>Note</dt><dd>This template must be instantiated for every custom struct/class that needs to be passed as a result or parameter via RPC </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Serial</td><td>The type of serial object to use </td></tr>
    <tr><td class="paramname">Value</td><td>The type of generic object to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The object to be serialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Serial The serialized value </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
